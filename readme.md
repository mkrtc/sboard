# Тестовое задание для разработчика: Full-stack приложение с Event Sourcing и историей версий для [Sboard](https://sboard.online/)

**Демонстрацию работы можно посмотреть [здесь](url)**

## Быстрый старт

- Установить приложение
    ```bash
    git clone https://github.com/mkrtc/sboard.git
    ```
- Перейти в папку с приложением
    ```bash
    cd ./sboard
    ```
- Собрать docker compose и запустить
  ```bash
  sudo docker compose run --build
  sudo docker compose up
  ```
- Открыть `localhost:3000`

## Оглавления
- [Краткое описание ТЗ](#краткое-описание-тз-подробнее-можете-посмотреть-здесь)
- [Frontend](#frontend)
- [Backend](#backend)
- [Дополнительные задачи](#дополнительные-требования)
  
## Краткое описание ТЗ. Подробнее можете посмотреть [здесь]()

- ***Задача:***
  >Напишите full-stack приложение на TypeScript, состоящее из frontend и backend-частей. 
  Приложение должно демонстрировать работу архитектурного подхода Event Sourcing и 
  предоставлять функциональность истории версий на его основе.

Этапы и реализация:
### Frontend
`path: /sboard/client`
#### Интерфейс
- [X] **- Используйте canvas для отрисовки графических объектов.**
  
    >*В разработке было принято решение использовать дефолтный Canvas API, поскольку библиотеки по типу **[KonovaJS](https://konvajs.org/)** не смотря на свое удобство значительно облегчают работу, а в данном случае я хотел показать свое умение работать именно с ванильным Canvas API*
- [X] **- Минимальная графика — квадраты, которые можно перетаскивать мышкой.**
  
  >*Все реализовано по ТЗ. Бонусом так же реализована возможность добавление квадратов и очистки холста*

- [X] **- Справа от canvas расположить панель с историей версий:** 
  - [X] Каждая версия содержит метку времени. 
  - [X] Версии отображаются в виде кликабельных элементов списка. 
  - [X] При выборе версии отображение на canvas должно соответствовать состоянию на тот момент.
  
  >*Все ревизовано по ТЗ. Бонусом так же ревизована возможность продолжения события при откате. Т.е. если вы откатились на 3 событий назад, то сможете продолжить именно с этого события. Новые события(после отката) так жк будут записаны*

#### Функциональность
- [X] **- При завершении действия пользователя (например, отпускании мышки после 
перемещения квадрата), отправляйте событие на сервер через WebSocket.**
- [X] **- После получения подтверждения от сервера обновляйте список версий**

#### Ограничения
- [X] **- Использование React — `необязательно`.**
  
  >В разработке был использован фреймворк **[nextjs](https://nextjs.org/)** 
- [X] **- Использование Canvas API (или обёрток) — `обязательно`.**
    >В разработке был использован дефолтный Canvas API. Подробнее объяснил [здесь](#frontend)

### Backend

`path /sboard/server`

#### Архитектура
- [X] **- Реализовать на NestJS.**
- [X] **- Обеспечить работу через WebSocket.**
  >Вебсокеты работают с помошю библиотек **@nestjs/websockets** и **@nestjs/platform-socket.io**. Подробнее [здесь](https://docs.nestjs.com/websockets/gateways).
- [X] **- Использовать PostgreSQL для хранения данных.**

#### Функциональность
- [X] **- Получение полного состояния (на основе всех ивентов).**
- [X] **- Получение состояния до определённого события (например, по ID или дате).**
  >Получение состояния работает по ID 
- [X] **- Получение списка всех версий (событий).**
  >Доступно по эндпоинту: `[GET] /canvas-events`
- [X] **- При получении события от фронта сохранять событие в базе данных**
  
#### Типы событий (примерные):
Поскольку тип являлись примерами, пришлось немного измени/добавить в угоду масштабируемости.

*Что изменилось/добавилось:*
- **SquareCreated - create_figure** 
  >Название **figure** подходит больше, поскольку если нужно будет в будущем добавлять новые фигуры, то не придется для этого создавать новые события по типу: **CircleCreated** или **TriangleCreated**.
- **SquareMoved - move_figure**
- **SquareDeleted - delete_figure**
  >Несмотря на то что удаление фигуры полностью реализована на стороне бэкенда, на стороне фронтенда оно не реализована.

Новые события:
- **get_event** - Получить определенное событие. Событие не возвращает событие а возвращает(точнее эмитит на `update_canvas`) состояния до/включительно этого события.
- **get_last_event** - Эмитит последнее актуальное состояние на `update_canvas`.
- **clear_canvas** - Очищает канвас.
  >ВАЖНО!!! Событие не удаляет предыдущее события, а именно добавляет новое событие. Если при восстановлении метод `.replaySnapshot()` Доходит до ивента `clear_canvas` то просто очищает массив.
- **update_canvas** - (Для клиента) Подписка на обновление канваса.

#### Требования к хранилищу
- [X] **- События должны храниться отдельно (event store).** 
  >Все события хранятся в базе данных в виде отдельных сущностей. Таблица: `events`
- [X] **- Состояние должно вычисляться on-the-fly, при запросе, а не кэшироваться в базе.** 
  >Состояние вычитывается на основе ивентов и ближайшего снапшота. Метод для восстановления события: `.replaySnapshot()`
- [X] **- Отдельно хранить снимки, например каждый 10-ый ивент. Использовать их, для более быстрого восстановления состояния (опционально)**
  >На каждый 10й ивент создается новый снапшот который с подошью метода `.replaySnapshot()` восстанавливает состояния до текущего ивента включительно и сохраняет в колонке `state`. так же новый снапшот создается если пользователь решил что хочет откатится на n событий назад и продолжить оттуда. Таблица: `canvas-snapshots`

### Дополнительные требования
- [X] **- Реализация кода на TypeScript на всех уровнях.** 
- [X] **- Хорошая архитектурная организация кода (модули, слои).**
  >Архитектура бэкенда основан на модульной архитектуру на котором построен **[nestjs](https://nestjs.com/)**. Она и так удобная, не вижу смысла его менять.
  >
  >Подробнее про архитектуру фронтэнда можете почитать [здесь](#архитектура-frontend)
- [X] **- Приветствуется покрытие основного бизнес-алгоритма (event reducer) тестами.**
  >Все бэекенд сущности покрыти юнит тестами. 
  >Запуск:
  ```bash
  cd server
  npm run test
  ``` 
- [X] Программа должна обрабатывать ошибки: например, невалидные события или попытка запросить несуществующую версию.
  >Все события и эндпоинты валидированы с помошью библиотек: [class-validator](https://www.npmjs.com/package/class-validator) и [class-transformer](https://www.npmjs.com/package/class-transformer)

## Архитектура Frontend